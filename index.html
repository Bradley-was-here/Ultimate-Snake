<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Snake – Eat, Dodge, Power-ups</title>
<style>
:root{--bg:#0b0f14;--panel:#121a24;--text:#e7f0ff;--muted:#9bb0cc}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
header{display:flex;flex-wrap:wrap;gap:10px;align-items:flex-start;justify-content:space-between;
  padding:10px 12px;background:linear-gradient(180deg,rgba(18,26,36,.95),rgba(18,26,36,.65));
  border-bottom:1px solid rgba(155,176,204,.18);position:sticky;top:0;z-index:10;backdrop-filter:blur(8px)}
.stats{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
.pill{background:rgba(155,176,204,.10);border:1px solid rgba(155,176,204,.18);padding:6px 10px;border-radius:999px;font-weight:900}
.pill span{color:var(--muted);margin-right:6px}
.toolbar{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
.tool{display:flex;gap:8px;align-items:center;font-weight:900;color:var(--muted);
  background:rgba(155,176,204,.08);border:1px solid rgba(155,176,204,.18);border-radius:12px;padding:6px 10px}
select,input,button{font-weight:900}
select,input[type="number"]{height:30px;border-radius:10px;border:1px solid rgba(155,176,204,.22);
  background:rgba(155,176,204,.10);color:var(--text);padding:0 8px;outline:none}
input[type="checkbox"]{width:18px;height:18px}
button{background:rgba(155,176,204,.12);border:1px solid rgba(155,176,204,.22);color:var(--text);
  padding:8px 12px;border-radius:10px;cursor:pointer}
button:active{transform:translateY(1px)}
main{display:grid;place-items:center;padding:10px}
canvas{background:#070a0e;border-radius:18px;border:2px solid rgba(155,176,204,.18);touch-action:none}
.hint{color:var(--muted);font-size:13px;padding:8px 12px;text-align:center}
.overlay{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);z-index:50;padding:18px}
.card{width:min(720px,94vw);background:rgba(18,26,36,.95);border:1px solid rgba(155,176,204,.22);
  border-radius:18px;padding:16px;box-shadow:0 12px 44px rgba(0,0,0,.55);word-break:break-word}
.card h2{margin:0 0 8px}
.card p{margin:8px 0;color:var(--muted)}
kbd{background:rgba(155,176,204,.12);border:1px solid rgba(155,176,204,.22);padding:2px 6px;border-radius:8px;font-weight:900;color:var(--text)}
.small{font-size:12px;color:var(--muted);font-weight:800}
</style>
</head>
<body>
<header>
  <div class="stats">
    <div class="pill"><span>Score</span><b id="score">0</b></div>
    <div class="pill"><span>High</span><b id="high">0</b></div>
    <div class="pill"><span>Mode</span><b id="modeLabel">Eat</b></div>
    <div class="pill"><span>Apples</span><b id="appleLabel">1</b></div>
    <div class="pill"><span>Shield</span><b id="shieldLabel">0</b></div>
    <div class="pill"><span>Slow</span><b id="slowLabel">0</b></div>
    <div class="pill"><span>Freeze</span><b id="freezeLabel">0</b></div>
    <div class="pill"><span>x2</span><b id="doubleLabel">0</b></div>
    <div class="pill"><span>Magnet</span><b id="magnetLabel">0</b></div>
  </div>

  <div class="toolbar">
    <div class="tool">Mode
      <select id="modeSelect" aria-label="Mode">
        <option value="eat">Eat</option>
        <option value="dodge">Dodge</option>
      </select>
    </div>

    <div class="tool">Apples
      <input id="appleCount" type="number" min="1" max="12" value="1" aria-label="Apple count">
    </div>

    <div class="tool" title="In dodge mode, adds a new apple every 8 points (up to 12).">
      <input id="wavesToggle" type="checkbox">
      Waves
    </div>

    <div class="tool" title="In dodge mode, apples speed up as you score.">
      <input id="rampToggle" type="checkbox">
      Speed ramp
    </div>

    <div class="tool" title="Power-ups: Off disables all power-up spawns. Custom lets you pick which ones can spawn.">
      Power-ups
      <select id="powerMode">
        <option value="off">Off</option>
        <option value="custom">Custom</option>
      </select>
    </div>

    <div class="tool" style="flex-wrap:wrap;max-width:min(860px,96vw)">
      <span class="small">Enabled:</span>
      <label class="small"><input id="pShield" type="checkbox"> Shield</label>
      <label class="small"><input id="pSlow" type="checkbox"> Slow</label>
      <label class="small"><input id="pFreeze" type="checkbox"> Freeze</label>
      <label class="small"><input id="pDouble" type="checkbox"> x2</label>
      <label class="small"><input id="pMagnet" type="checkbox"> Magnet</label>
      <label class="small"><input id="pShrink" type="checkbox"> Shrink</label>
    </div>

    <button id="pauseBtn" type="button">Pause</button>
    <button id="restartBtn" type="button">Restart</button>
  </div>
</header>

<main>
  <canvas id="game" width="420" height="420" aria-label="Snake canvas"></canvas>
</main>

<div class="hint">
  Desktop: <kbd>↑</kbd><kbd>↓</kbd><kbd>←</kbd><kbd>→</kbd> or <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> • <kbd>Space</kbd>/<kbd>P</kbd> pause • <kbd>R</kbd> restart<br>
  Mobile: swipe to turn (easy sensitivity). Tap board to pause.
</div>

<div class="overlay" id="gameOverOverlay" role="dialog" aria-modal="true">
  <div class="card">
    <h2>Game Over</h2>
    <p id="overText"></p>
    <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:12px;">
      <button id="playAgain" type="button">Play again</button>
    </div>
  </div>
</div>

<div class="overlay" id="errorOverlay" role="dialog" aria-modal="true">
  <div class="card">
    <h2>Something went wrong</h2>
    <p id="errorText"></p>
    <p style="color:#9bb0cc;">Tip: download + unzip, then open <b>index.html</b> in a real browser (not a preview).</p>
  </div>
</div>

<script>
(() => {
  const errorOverlay = document.getElementById('errorOverlay');
  const errorText = document.getElementById('errorText');
  window.addEventListener('error', (e) => {
    errorText.textContent = (e && e.message) ? e.message : 'Unknown error';
    errorOverlay.style.display = 'grid';
  });

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function rrPath(x,y,w,h,r){
    r=Math.max(0,Math.min(r,w/2,h/2));
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  const GRID = 21;
  const cell = Math.floor(canvas.width / GRID);
  const pad = Math.floor((canvas.width - cell * GRID) / 2);

  // UI
  const scoreEl = document.getElementById('score');
  const highEl = document.getElementById('high');
  const modeLabel = document.getElementById('modeLabel');
  const appleLabel = document.getElementById('appleLabel');
  const shieldLabel = document.getElementById('shieldLabel');
  const slowLabel = document.getElementById('slowLabel');
  const freezeLabel = document.getElementById('freezeLabel');
  const doubleLabel = document.getElementById('doubleLabel');
  const magnetLabel = document.getElementById('magnetLabel');

  const modeSelect = document.getElementById('modeSelect');
  const appleCountInput = document.getElementById('appleCount');
  const wavesToggle = document.getElementById('wavesToggle');
  const rampToggle = document.getElementById('rampToggle');

  const powerModeSelect = document.getElementById('powerMode');
  const pShield = document.getElementById('pShield');
  const pSlow = document.getElementById('pSlow');
  const pFreeze = document.getElementById('pFreeze');
  const pDouble = document.getElementById('pDouble');
  const pMagnet = document.getElementById('pMagnet');
  const pShrink = document.getElementById('pShrink');

  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');

  const overOverlay = document.getElementById('gameOverOverlay');
  const overText = document.getElementById('overText');
  const playAgain = document.getElementById('playAgain');

  // Storage
  const PREF_KEY = 'snake_mode_prefs_v4';
  const HS_EAT = 'snake_hs_eat_v4';
  const HS_DODGE = 'snake_hs_dodge_v4';

  function loadJson(key, fallback){
    try{ const raw = localStorage.getItem(key); return raw ? JSON.parse(raw) : fallback; }
    catch{ return fallback; }
  }
  function saveJson(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); } catch{} }

  // Preferences
  let prefs = loadJson(PREF_KEY, {
    mode:'eat', apples:1, waves:true, ramp:true,
    powerMode:'custom',
    enabledPowers: { shield:true, slow:true, freeze:true, double:true, magnet:true, shrink:true }
  });
  if (prefs.mode !== 'eat' && prefs.mode !== 'dodge') prefs.mode = 'eat';
  prefs.apples = Math.max(1, Math.min(12, Math.floor(Number(prefs.apples)||1)));
  prefs.waves = !!prefs.waves;
  prefs.ramp = !!prefs.ramp;
  if (prefs.powerMode !== 'off' && prefs.powerMode !== 'custom') prefs.powerMode = 'custom';
  prefs.enabledPowers = prefs.enabledPowers || {};
  const ep = (k, d=true) => (prefs.enabledPowers[k] === undefined ? d : !!prefs.enabledPowers[k]);

  // Colors
  const COL = {
    grid: 'rgba(155,176,204,.08)',
    bg: '#070a0e',
    snake: '#b7d7ff',
    head: '#e7f0ff',
    food: '#7cf7c5',
    foodGlow: 'rgba(124,247,197,.35)',
    hazard: '#ff6b6b',
    hazardGlow: 'rgba(255,107,107,.35)',
    power: '#c28bff',
    powerGlow: 'rgba(194,139,255,.35)',
    text: '#e7f0ff'
  };

  // Game state
  let mode = prefs.mode;
  let appleTarget = prefs.apples;
  let wavesOn = prefs.waves;
  let rampOn = prefs.ramp;

  let powerMode = prefs.powerMode; // off | custom
  let enabledPowers = {
    shield: ep('shield'), slow: ep('slow'), freeze: ep('freeze'),
    double: ep('double'), magnet: ep('magnet'), shrink: ep('shrink')
  };

  let paused = false;
  let gameOver = false;

  let snake = [];
  let dir = {x:1,y:0};
  let nextDir = {x:1,y:0};
  let apples = []; // {x,y,dx,dy}
  let score = 0;
  let grow = 0;

  // Dodge difficulty vars
  let ticks = 0;
  let survivalTicks = 0;
  let appleMoveEvery = 3; // lower = faster

  // Power-up effects (timers in ticks)
  let shield = 0;        // blocks hits
  let slowTicks = 0;     // slows apples
  let freezeTicks = 0;   // stops apples moving
  let doubleTicks = 0;   // double score for a while
  let magnetTicks = 0;   // eat mode: nearby apples auto-collect
  let powerUp = null;    // {x,y,type}
  let powerAge = 0;

  const POWER_TYPES = ['shield','slow','freeze','double','magnet','shrink'];
  const POWER_DESPAWN_TICKS = 70;

  // Timing
  let speedLevel = 1;
  let tickMsBase = 120;
  let tickMs = tickMsBase;

  function clampInt(n, lo, hi, fallback){
    n = Number(n);
    if (!Number.isFinite(n)) return fallback;
    return Math.max(lo, Math.min(hi, Math.floor(n)));
  }

  function getHsKey(){ return (mode === 'dodge') ? HS_DODGE : HS_EAT; }

  function same(a,b){ return a.x===b.x && a.y===b.y; }
  function randCell(){ return {x:Math.floor(Math.random()*GRID), y:Math.floor(Math.random()*GRID)}; }
  function manhattan(a,b){ return Math.abs(a.x-b.x) + Math.abs(a.y-b.y); }

  function cellOccupiedBySnake(c){ return snake.some(s => same(s,c)); }
  function cellOccupiedByApples(c){ return apples.some(a => a && same(a,c)); }
  function cellOccupiedByPower(c){ return powerUp && same(powerUp, c); }

  function randomFreeCell(){
    for (let k=0;k<250;k++){
      const c = randCell();
      if (!cellOccupiedBySnake(c) && !cellOccupiedByApples(c) && !cellOccupiedByPower(c)) return c;
    }
    for (let y=0;y<GRID;y++) for (let x=0;x<GRID;x++){
      const c = {x,y};
      if (!cellOccupiedBySnake(c) && !cellOccupiedByApples(c) && !cellOccupiedByPower(c)) return c;
    }
    return {x:0,y:0};
  }

  function makeApple(){
    const pos = randomFreeCell();
    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    const d = dirs[Math.floor(Math.random()*dirs.length)];
    return {x:pos.x,y:pos.y,dx:d.x,dy:d.y};
  }

  function ensureAppleCount(){
    while (apples.length < appleTarget) apples.push(makeApple());
    while (apples.length > appleTarget) apples.pop();
  }

  function setSpeed(level){
    speedLevel = Math.max(1, Math.min(10, level));
    tickMs = Math.round(tickMsBase / (0.85 + speedLevel * 0.22));
  }

  // Toast
  function toast(msg){
    let el = document.getElementById('toast');
    if (!el){
      el = document.createElement('div');
      el.id = 'toast';
      el.style.position = 'fixed';
      el.style.left = '50%';
      el.style.bottom = '18px';
      el.style.transform = 'translateX(-50%)';
      el.style.background = 'rgba(18,26,36,.95)';
      el.style.border = '1px solid rgba(155,176,204,.22)';
      el.style.color = 'var(--text)';
      el.style.padding = '10px 12px';
      el.style.borderRadius = '14px';
      el.style.fontWeight = '900';
      el.style.zIndex = '60';
      el.style.maxWidth = '92vw';
      el.style.textAlign = 'center';
      document.body.appendChild(el);
    }
    el.textContent = msg;
    el.style.display = 'block';
    clearTimeout(toast._t);
    toast._t = setTimeout(()=>{ el.style.display='none'; }, 1600);
  }

  function updateUI(){
    scoreEl.textContent = score;
    modeLabel.textContent = (mode === 'dodge') ? 'Dodge' : 'Eat';
    appleLabel.textContent = String(appleTarget);
    shieldLabel.textContent = String(shield);
    slowLabel.textContent = String(Math.ceil(Math.max(0, slowTicks)/10));
    freezeLabel.textContent = String(Math.ceil(Math.max(0, freezeTicks)/10));
    doubleLabel.textContent = String(Math.ceil(Math.max(0, doubleTicks)/10));
    magnetLabel.textContent = String(Math.ceil(Math.max(0, magnetTicks)/10));

    let hs = 0;
    try{ hs = Number(localStorage.getItem(getHsKey()) || 0); } catch {}
    highEl.textContent = hs;

    pauseBtn.textContent = paused ? 'Resume' : 'Pause';

    // Show/hide power checkboxes depending on power mode
    const disabled = (powerMode === 'off');
    const setDisabled = (el) => { el.disabled = disabled; el.parentElement.style.opacity = disabled ? 0.5 : 1; };
    [pShield,pSlow,pFreeze,pDouble,pMagnet,pShrink].forEach(setDisabled);
  }

  function savePrefs(){
    saveJson(PREF_KEY, {
      mode, apples: appleTarget, waves: wavesOn, ramp: rampOn,
      powerMode,
      enabledPowers: {...enabledPowers}
    });
  }

  function reset(){
    score = 0;
    grow = 0;
    paused = false;
    gameOver = false;
    overOverlay.style.display = 'none';

    ticks = 0;
    survivalTicks = 0;
    appleMoveEvery = 3;

    shield = 0;
    slowTicks = 0;
    freezeTicks = 0;
    doubleTicks = 0;
    magnetTicks = 0;
    powerUp = null;
    powerAge = 0;

    const cx = Math.floor(GRID/2);
    const cy = Math.floor(GRID/2);
    snake = [{x:cx-1,y:cy},{x:cx,y:cy},{x:cx+1,y:cy}];
    dir = {x:1,y:0};
    nextDir = {x:1,y:0};

    apples = [];
    ensureAppleCount();

    setSpeed(mode === 'dodge' ? Math.max(2, speedLevel) : speedLevel);

    updateUI();
  }

  function endGame(reason){
    gameOver = true;
    paused = true;

    const hsKey = getHsKey();
    let hs = 0;
    try{ hs = Number(localStorage.getItem(hsKey) || 0); } catch {}
    if (score > hs) {
      hs = score;
      try{ localStorage.setItem(hsKey, String(hs)); } catch {}
    }

    updateUI();
    overText.textContent = `${reason ? (reason + " • ") : ""}Mode: ${(mode==='dodge')?'Dodge':'Eat'} • Score: ${score} • High score: ${hs}`;
    overOverlay.style.display = 'grid';
  }

  function validTurn(from,to){ return !(from.x + to.x === 0 && from.y + to.y === 0); }
  function requestDir(d){ if (validTurn(dir,d)) nextDir = d; }

  // Power spawn rules
  function powerSpawnsEnabled(){
    return powerMode !== 'off';
  }
  function enabledPowerList(){
    const list = [];
    for (const t of POWER_TYPES){
      if (enabledPowers[t]) list.push(t);
    }
    return list;
  }

  function maybeSpawnPowerUp(){
    if (!powerSpawnsEnabled()) return;
    if (powerUp) return;

    const list = enabledPowerList();
    if (list.length === 0) return;

    // Spawn chance tuned: more in dodge (harder), less in eat
    const chance = (mode === 'dodge') ? 0.55 : 0.45;
    if (Math.random() > chance) return;

    const type = list[Math.floor(Math.random()*list.length)];
    const pos = randomFreeCell();
    powerUp = {x:pos.x,y:pos.y,type};
    powerAge = 0;
    const pretty = ({
      shield:'Shield (S)',
      slow:'Slow (⏳)',
      freeze:'Freeze (❄)',
      double:'x2 Score',
      magnet:'Magnet',
      shrink:'Shrink'
    })[type] || type;
    toast('Power-up spawned: ' + pretty);
  }

  function applyPowerUp(type){
    if (type === 'shield'){
      shield = Math.min(3, shield + 1);
      toast('Picked up: Shield (+1)');
    } else if (type === 'slow'){
      slowTicks = Math.min(220, slowTicks + 100);
      toast('Picked up: Slow');
    } else if (type === 'freeze'){
      freezeTicks = Math.min(180, freezeTicks + 90);
      toast('Picked up: Freeze');
    } else if (type === 'double'){
      doubleTicks = Math.min(220, doubleTicks + 110);
      toast('Picked up: x2 score');
    } else if (type === 'magnet'){
      magnetTicks = Math.min(220, magnetTicks + 110);
      toast('Picked up: Magnet');
    } else if (type === 'shrink'){
      // Only makes sense if you have length to shrink
      const shrinkBy = 2;
      if (snake.length > 3) {
        snake.splice(0, Math.min(shrinkBy, snake.length - 3));
        toast('Picked up: Shrink');
      } else {
        toast('Shrink wasted (too short)');
      }
    }
  }

  function tickPowerUpLifetime(){
    if (powerUp){
      powerAge += 1;
      if (powerAge >= POWER_DESPAWN_TICKS){
        powerUp = null;
        powerAge = 0;
      }
    }
  }

  // Apple movement in dodge mode
  function moveApple(a){
    let nx = a.x + a.dx;
    let ny = a.y + a.dy;

    if (nx < 0 || nx >= GRID){ a.dx *= -1; nx = a.x + a.dx; }
    if (ny < 0 || ny >= GRID){ a.dy *= -1; ny = a.y + a.dy; }

    if (cellOccupiedBySnake({x:nx,y:ny})){
      a.dx *= -1; a.dy *= -1;
      nx = a.x + a.dx; ny = a.y + a.dy;
      if (nx < 0 || nx >= GRID || ny < 0 || ny >= GRID || cellOccupiedBySnake({x:nx,y:ny})){
        nx = a.x; ny = a.y;
      }
    }
    a.x = nx; a.y = ny;
  }

  // Scoring helper (double score)
  function addScore(pts){
    const mult = (doubleTicks > 0) ? 2 : 1;
    score += pts * mult;
  }

  // Main step
  function step(){
    if (paused || gameOver) return;

    ticks += 1;

    // Decay effect timers
    if (slowTicks > 0) slowTicks -= 1;
    if (freezeTicks > 0) freezeTicks -= 1;
    if (doubleTicks > 0) doubleTicks -= 1;
    if (magnetTicks > 0) magnetTicks -= 1;

    dir = nextDir;
    const head = snake[snake.length-1];
    const newHead = {x: head.x + dir.x, y: head.y + dir.y};

    if (newHead.x < 0 || newHead.x >= GRID || newHead.y < 0 || newHead.y >= GRID){
      return endGame('Hit wall');
    }

    const bodyToCheck = (mode === 'eat' ? snake : snake.slice(1));
    if (bodyToCheck.some(s => same(s, newHead))){
      return endGame('Hit self');
    }

    snake.push(newHead);

    // Pickup power-up
    if (powerUp && same(powerUp, newHead)){
      applyPowerUp(powerUp.type);
      powerUp = null;
      powerAge = 0;
    }

    if (mode === 'eat'){
      // Magnet: auto-collect apples within distance 2
      if (magnetTicks > 0){
        for (let i=0;i<apples.length;i++){
          if (manhattan(newHead, apples[i]) <= 2){
            addScore(1);
            grow += 2;
            apples[i] = makeApple();
            // chance to spawn a power-up every 6 points of (raw) score-ish:
            if (score > 0 && score % 6 === 0) maybeSpawnPowerUp();
          }
        }
      }

      // Eat if you land on an apple
      let ateIndex = -1;
      for (let i=0;i<apples.length;i++){
        if (same(apples[i], newHead)){ ateIndex = i; break; }
      }
      if (ateIndex >= 0){
        addScore(1);
        grow += 2;
        apples[ateIndex] = makeApple();
        if (score > 0 && score % 6 === 0) maybeSpawnPowerUp();
      }

      if (grow > 0) grow -= 1;
      else snake.shift();

    } else {
      // Dodge mode: apples are hazards
      if (apples.some(a => same(a, newHead))){
        if (shield > 0){
          shield -= 1;
          toast('Shield saved you!');
        } else {
          return endGame('Hit apple');
        }
      }

      survivalTicks += 1;
      if (survivalTicks % 4 === 0){
        addScore(1);
        if (score > 0 && score % 8 === 0) maybeSpawnPowerUp();

        if (rampOn && score % 5 === 0){
          // 3 -> 2 -> 1 as score grows
          appleMoveEvery = Math.max(1, 3 - Math.floor(score / 10));
        }

        if (wavesOn && score % 8 === 0 && appleTarget < 12){
          appleTarget += 1;
          appleCountInput.value = String(appleTarget);
          savePrefs();
          toast('Wave! +1 apple');
        }
      }

      snake.shift();

      // Move apples like dodgeballs unless frozen
      if (freezeTicks <= 0){
        const slowFactor = (slowTicks > 0) ? 2 : 1;
        const moveEvery = appleMoveEvery * slowFactor;
        if (ticks % moveEvery === 0){
          for (const a of apples) moveApple(a);
        }
      }

      const h2 = snake[snake.length-1];
      if (apples.some(a => same(a, h2))){
        if (shield > 0){
          shield -= 1;
          toast('Shield saved you!');
        } else {
          return endGame('Apple hit you');
        }
      }
    }

    // Power-up lifetime
    tickPowerUpLifetime();

    // Keep apple count correct
    ensureAppleCount();
  }

  function draw(){
    ctx.fillStyle = COL.bg;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Grid
    ctx.strokeStyle = COL.grid;
    ctx.lineWidth = 1;
    for (let i=0;i<=GRID;i++){
      const p = pad + i*cell + 0.5;
      ctx.beginPath(); ctx.moveTo(pad+0.5,p); ctx.lineTo(pad+GRID*cell+0.5,p); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(p,pad+0.5); ctx.lineTo(p,pad+GRID*cell+0.5); ctx.stroke();
    }

    // Apples
    for (const a of apples){
      const ax = pad + a.x*cell;
      const ay = pad + a.y*cell;
      const glow = (mode === 'dodge') ? COL.hazardGlow : COL.foodGlow;
      const fill = (mode === 'dodge') ? COL.hazard : COL.food;
      ctx.fillStyle = glow;
      rrPath(ax+cell*0.08, ay+cell*0.08, cell*0.84, cell*0.84, cell*0.22); ctx.fill();
      ctx.fillStyle = fill;
      rrPath(ax+cell*0.18, ay+cell*0.18, cell*0.64, cell*0.64, cell*0.18); ctx.fill();
    }

    // Power-up
    if (powerUp){
      const px = pad + powerUp.x*cell;
      const py = pad + powerUp.y*cell;
      ctx.fillStyle = COL.powerGlow;
      rrPath(px+cell*0.08, py+cell*0.08, cell*0.84, cell*0.84, cell*0.22); ctx.fill();
      ctx.fillStyle = COL.power;
      rrPath(px+cell*0.18, py+cell*0.18, cell*0.64, cell*0.64, cell*0.18); ctx.fill();

      ctx.fillStyle = '#0b0f14';
      ctx.font = '900 12px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const glyph = ({shield:'S', slow:'⏳', freeze:'❄', double:'x2', magnet:'M', shrink:'↧'})[powerUp.type] || '?';
      ctx.fillText(glyph, px + cell*0.5, py + cell*0.52);
    }

    // Snake
    for (let i=0;i<snake.length;i++){
      const s = snake[i];
      const x = pad + s.x*cell;
      const y = pad + s.y*cell;
      const isHead = (i === snake.length-1);
      ctx.fillStyle = isHead ? COL.head : COL.snake;
      rrPath(x+cell*0.12, y+cell*0.12, cell*0.76, cell*0.76, cell*0.22); ctx.fill();
    }

    if (paused && !gameOver){
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = COL.text;
      ctx.font = '900 22px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Paused', canvas.width/2, canvas.height/2);
    }
  }

  // Game loop
  let last = performance.now();
  let acc = 0;
  function loop(t){
    const dt = t - last;
    last = t;
    acc += dt;
    while (acc >= tickMs){ step(); acc -= tickMs; }
    draw();
    updateUI();
    requestAnimationFrame(loop);
  }

  function togglePause(){
    if (gameOver) return;
    paused = !paused;
    updateUI();
  }

  // Inputs
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (k === 'p' || k === ' ') { togglePause(); e.preventDefault(); return; }
    if (k === 'r') { reset(); e.preventDefault(); return; }

    if (k === 'arrowup' || k === 'w') requestDir({x:0,y:-1});
    else if (k === 'arrowdown' || k === 's') requestDir({x:0,y:1});
    else if (k === 'arrowleft' || k === 'a') requestDir({x:-1,y:0});
    else if (k === 'arrowright' || k === 'd') requestDir({x:1,y:0});
  }, { passive:false });

  // Mobile swipe + tap to pause
  let touchStart = null;
  let didSwipe = false;
  function getTouchPos(ev){
    const t = (ev.touches && ev.touches[0]) || (ev.changedTouches && ev.changedTouches[0]);
    return {x:t.clientX,y:t.clientY};
  }
  canvas.addEventListener('touchstart', (ev)=>{
    ev.preventDefault();
    touchStart = getTouchPos(ev);
    didSwipe = false;
  }, {passive:false});

  canvas.addEventListener('touchmove', (ev)=>{
    ev.preventDefault();
    if (!touchStart) return;
    const cur = getTouchPos(ev);
    const dx = cur.x - touchStart.x;
    const dy = cur.y - touchStart.y;
    const absX = Math.abs(dx), absY = Math.abs(dy);
    const TH = 8;
    if (absX < TH && absY < TH) return;

    if (absX > absY) requestDir({x: dx > 0 ? 1 : -1, y:0});
    else requestDir({x:0, y: dy > 0 ? 1 : -1});
    didSwipe = true;
    touchStart = null;
  }, {passive:false});

  canvas.addEventListener('touchend', (ev)=>{
    ev.preventDefault();
    if (!didSwipe) togglePause();
    touchStart = null;
  }, {passive:false});

  // UI handlers
  pauseBtn.addEventListener('click', togglePause);
  restartBtn.addEventListener('click', () => reset());
  playAgain.addEventListener('click', () => reset());

  function applySettingsAndRestart(){
    mode = (modeSelect.value === 'dodge') ? 'dodge' : 'eat';
    appleTarget = clampInt(appleCountInput.value, 1, 12, 1);
    wavesOn = !!wavesToggle.checked;
    rampOn = !!rampToggle.checked;

    powerMode = (powerModeSelect.value === 'off') ? 'off' : 'custom';
    enabledPowers = {
      shield: !!pShield.checked,
      slow: !!pSlow.checked,
      freeze: !!pFreeze.checked,
      double: !!pDouble.checked,
      magnet: !!pMagnet.checked,
      shrink: !!pShrink.checked
    };

    savePrefs();
    reset();
  }

  // Init UI from prefs
  modeSelect.value = mode;
  appleCountInput.value = String(appleTarget);
  wavesToggle.checked = wavesOn;
  rampToggle.checked = rampOn;

  powerModeSelect.value = powerMode;
  pShield.checked = enabledPowers.shield;
  pSlow.checked = enabledPowers.slow;
  pFreeze.checked = enabledPowers.freeze;
  pDouble.checked = enabledPowers.double;
  pMagnet.checked = enabledPowers.magnet;
  pShrink.checked = enabledPowers.shrink;

  modeSelect.addEventListener('change', applySettingsAndRestart);
  appleCountInput.addEventListener('change', applySettingsAndRestart);
  wavesToggle.addEventListener('change', applySettingsAndRestart);
  rampToggle.addEventListener('change', applySettingsAndRestart);
  powerModeSelect.addEventListener('change', applySettingsAndRestart);

  [pShield,pSlow,pFreeze,pDouble,pMagnet,pShrink].forEach(el => el.addEventListener('change', applySettingsAndRestart));

  // Double-check (pre-flight)
  const required = ['score','high','modeLabel','appleLabel','shieldLabel','slowLabel','freezeLabel','doubleLabel','magnetLabel','modeSelect','appleCount','wavesToggle','rampToggle','powerMode','pShield','pSlow','pFreeze','pDouble','pMagnet','pShrink','pauseBtn','restartBtn','gameOverOverlay','overText','game'];
  for (const id of required){
    if (!document.getElementById(id)) throw new Error('Missing element: ' + id);
  }

  // Start
  setSpeed(1);
  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
